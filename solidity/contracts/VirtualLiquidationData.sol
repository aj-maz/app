// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

interface IOracleRelayer {
    struct OracleRelayerCollateralParams {
        // Usually an oracle security module that enforces delays to fresh price feeds
        address oracle;
        // CRatio used to compute the 'safePrice' - the price used when generating debt in SAFEEngine
        uint256 safetyCRatio;
        // CRatio used to compute the 'liquidationPrice' - the price used when liquidating SAFEs
        uint256 liquidationCRatio;
    }

    function redemptionPrice() external returns (uint256);
    function redemptionRate() external view returns (uint256);
    function cParams(bytes32) external view returns (OracleRelayerCollateralParams memory);
}

interface ISAFEEngine {
    struct SAFEEngineParams {
        // Total amount of debt that a single safe can generate
        uint256 safeDebtCeiling; // [wad]
        // Maximum amount of debt that can be issued
        uint256 globalDebtCeiling; // [rad]
    }

    struct SAFEEngineCollateralParams {
        // Maximum amount of debt that can be generated with this collateral type
        uint256 debtCeiling; // [rad]
        // Minimum amount of debt that must be generated by a SAFE using this collateral
        uint256 debtFloor; // [rad]
    }

    struct SAFEEngineCollateralData {
        // Total amount of debt issued by a collateral type
        uint256 debtAmount; // [wad]
        // Accumulated rate of a collateral type
        uint256 accumulatedRate; // [ray]
        // Floor price at which a SAFE is allowed to generate debt
        uint256 safetyPrice; // [ray]
        // Price at which a SAFE gets liquidated
        uint256 liquidationPrice; // [ray]
    }

    function globalDebt() external view returns (uint256);
    function params() external view returns (SAFEEngineParams memory);
    function cParams(bytes32) external view returns (SAFEEngineCollateralParams memory);
    function cData(bytes32) external view returns (SAFEEngineCollateralData memory);
}

interface ILiquidationEngine {
    struct LiquidationEngineCollateralParams {
        address collateralAuctionHouse;
        uint256 liquidationPenalty;
        uint256 liquidationQuantity;
    }

    function cParams(bytes32) external view returns (LiquidationEngineCollateralParams memory);
}

interface ITaxCollector {
    struct TaxCollectorParams {
        address primaryTaxReceiver;
        uint256 globalStabilityFee;
        uint256 maxSecondaryReceivers;
    }

    struct TaxCollectorCollateralParams {
        uint256 stabilityFee;
    }

    function params() external view returns (TaxCollectorParams memory);
    function cParams(bytes32) external view returns (TaxCollectorCollateralParams memory);
    function taxSingle(bytes32) external;
}

contract VirtualLiquidationData {
    struct LiquidationData {
        uint256 redemptionPrice;
        uint256 redemptionRate;
        uint256 globalDebt;
        uint256 globalDebtCeiling;
        uint256 safeDebtCeiling;
        TokenLiquidationData[] tokenLiquidationData;
    }

    struct TokenLiquidationData {
        uint256 accumulatedRate;
        uint256 debtFloor;
        uint256 liquidationPrice;
        uint256 safetyPrice;
        uint256 safetyCRatio;
        uint256 liquidationCRatio;
        uint256 liquidationPenalty;
        uint256 stabilityFee;
    }

    constructor(
        IOracleRelayer oracleRelayer,
        ISAFEEngine safeEngine,
        ILiquidationEngine liquidationEngine,
        ITaxCollector taxCollector,
        bytes32[] memory cTypes
    ) {
        ISAFEEngine.SAFEEngineParams memory _safeEngineParams = safeEngine.params();
        
        TokenLiquidationData[] memory tokenLiquidationData = new TokenLiquidationData[](cTypes.length);
        for (uint256 i = 0; i < cTypes.length; i++) {
            bytes32 cType = cTypes[i];
            taxCollector.taxSingle(cType);
            ISAFEEngine.SAFEEngineCollateralParams memory _safeEngineCParams = safeEngine.cParams(cType);
            ISAFEEngine.SAFEEngineCollateralData memory _safeEngineCData = safeEngine.cData(cType);
            IOracleRelayer.OracleRelayerCollateralParams memory _oracleRelayerCParams = oracleRelayer.cParams(cType);
            ILiquidationEngine.LiquidationEngineCollateralParams memory _liquidationEngineCParams =
                liquidationEngine.cParams(cType);
            ITaxCollector.TaxCollectorParams memory _taxCollectorParams = taxCollector.params();
            ITaxCollector.TaxCollectorCollateralParams memory _taxCollectorCParams = taxCollector.cParams(cType);

            tokenLiquidationData[i] = TokenLiquidationData({
                accumulatedRate: _safeEngineCData.accumulatedRate,
                debtFloor: _safeEngineCParams.debtFloor,
                liquidationPrice: _safeEngineCData.liquidationPrice,
                safetyPrice: _safeEngineCData.safetyPrice,
                safetyCRatio: _oracleRelayerCParams.safetyCRatio,
                liquidationCRatio: _oracleRelayerCParams.liquidationCRatio,
                liquidationPenalty: _liquidationEngineCParams.liquidationPenalty,
                stabilityFee: _taxCollectorParams.globalStabilityFee + _taxCollectorCParams.stabilityFee
            });
        }

        LiquidationData memory returnData = LiquidationData({
            redemptionPrice: oracleRelayer.redemptionPrice(),
            redemptionRate: oracleRelayer.redemptionRate(),
            globalDebt: safeEngine.globalDebt(),
            globalDebtCeiling: _safeEngineParams.globalDebtCeiling,
            safeDebtCeiling: _safeEngineParams.safeDebtCeiling,
            tokenLiquidationData: tokenLiquidationData
        });

        // encode return data
        bytes memory data = abi.encode(returnData);

        // force constructor return via assembly
        assembly {
            let dataStart := add(data, 32) // abi.encode adds an additional offset
            return(dataStart, sub(msize(), dataStart))
        }
    }
}
